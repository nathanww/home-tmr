"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jsonrpc_ts_1 = require("@fitbit/jsonrpc-ts");
const invariant = require("invariant");
const isBase64_1 = require("validator/lib/isBase64");
const types = require("./FDBTypes");
class BulkDataStream {
    constructor(token, disposer, onWrite) {
        this.length = 0;
        this.data = [];
        this.token = token;
        this.disposer = disposer;
        this.onWrite = onWrite;
    }
    write(buffer) {
        this.data.push(buffer);
        this.length += buffer.length;
        if (this.onWrite)
            this.onWrite(buffer.length, this.length);
    }
    finalize() {
        this.disposer();
        return Buffer.concat(this.data);
    }
}
exports.BulkDataStream = BulkDataStream;
class BulkData {
    constructor() {
        this.streams = new Map();
        this.nextToken = 0;
        this.handleWrite = ({ stream: token, data, encoding = 'base64' }) => {
            const stream = this.getStream(token);
            if (encoding === 'base64') {
                if (typeof data !== 'string' || !isBase64_1.default(data)) {
                    throw new jsonrpc_ts_1.InvalidParams('Data is not valid for encoding', { encoding });
                }
                stream.write(Buffer.from(data, encoding));
            }
            else if (encoding === 'none') {
                if (!Buffer.isBuffer(data)) {
                    throw new jsonrpc_ts_1.InvalidParams('Data is not valid for encoding', { encoding });
                }
                stream.write(data);
            }
            else {
                throw new jsonrpc_ts_1.InvalidParams('Invalid encoding', { encoding });
            }
        };
    }
    register(dispatcher) {
        dispatcher.method('io.write', types.IOWriteParams, this.handleWrite);
    }
    getStream(token) {
        const stream = this.streams.get(token);
        if (stream !== undefined)
            return stream;
        throw new jsonrpc_ts_1.InvalidParams('Unknown bulk data stream', { stream: token });
    }
    createWriteStream(onWrite) {
        const token = this.nextToken;
        this.nextToken += 1;
        invariant(!this.streams.has(token), 'Stream token already exists');
        const stream = new BulkDataStream(token, () => this.streams.delete(token), onWrite);
        this.streams.set(token, stream);
        return stream;
    }
}
exports.default = BulkData;
//# sourceMappingURL=BulkData.js.map