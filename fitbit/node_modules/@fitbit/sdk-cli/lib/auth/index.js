"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const authorization_request_1 = require("@openid/appauth/built/authorization_request");
const authorization_request_handler_1 = require("@openid/appauth/built/authorization_request_handler");
const authorization_service_configuration_1 = require("@openid/appauth/built/authorization_service_configuration");
const appAuthFlags = tslib_1.__importStar(require("@openid/appauth/built/flags"));
const node_support_1 = require("@openid/appauth/built/node_support");
const revoke_token_request_1 = require("@openid/appauth/built/revoke_token_request");
const token_request_1 = require("@openid/appauth/built/token_request");
const environment_1 = tslib_1.__importDefault(require("./environment"));
const storage_1 = tslib_1.__importDefault(require("./storage"));
const FitbitTokenRequestHandler_1 = tslib_1.__importDefault(require("./FitbitTokenRequestHandler"));
const ResourceOwnerPasswordRequest_1 = tslib_1.__importDefault(require("./ResourceOwnerPasswordRequest"));
appAuthFlags.IS_LOG = false;
const SCOPES = ['profile'];
const tokenHandler = new FitbitTokenRequestHandler_1.default();
function getAuthConfiguration() {
    const { apiUrl } = environment_1.default().config;
    return new authorization_service_configuration_1.AuthorizationServiceConfiguration({
        token_endpoint: `${apiUrl}/oauth2/token`,
        authorization_endpoint: `${apiUrl}/oauth2/authorize`,
        revocation_endpoint: `${apiUrl}/oauth2/revoke`,
    });
}
async function refreshToken(refreshToken) {
    const { clientId } = environment_1.default().config;
    try {
        const response = await tokenHandler.performTokenRequest(getAuthConfiguration(), new token_request_1.TokenRequest({
            client_id: clientId,
            redirect_uri: '',
            grant_type: token_request_1.GRANT_TYPE_REFRESH_TOKEN,
            refresh_token: refreshToken,
        }));
        await storage_1.default.set(response);
        return response.accessToken;
    }
    catch (ex) {
        await storage_1.default.clear();
        throw ex;
    }
}
exports.refreshToken = refreshToken;
function authError(msg) {
    return new Error(`Authorization error: ${msg}`);
}
function authorizationCallbackPromise(handler) {
    const notifier = new authorization_request_handler_1.AuthorizationNotifier();
    handler.setAuthorizationNotifier(notifier);
    return new Promise((resolve, reject) => {
        notifier.setAuthorizationListener((request, response, error) => {
            if (error) {
                if (error.errorDescription) {
                    return reject(authError(`${error.error}: ${error.errorDescription}`));
                }
                return reject(authError(error.error));
            }
            resolve({ request: request, response: response });
        });
    });
}
async function authorize() {
    const { clientId } = environment_1.default().config;
    const port = 13579;
    const redirectUri = `http://127.0.0.1:${port}`;
    const authorizationHandler = new node_support_1.NodeBasedHandler(port);
    authorizationHandler.performAuthorizationRequest(getAuthConfiguration(), new authorization_request_1.AuthorizationRequest({
        client_id: clientId,
        redirect_uri: redirectUri,
        scope: SCOPES.join(','),
        response_type: authorization_request_1.AuthorizationRequest.RESPONSE_TYPE_CODE,
    }, new node_support_1.NodeCrypto(), true));
    const { request, response } = await authorizationCallbackPromise(authorizationHandler);
    if (request.state !== response.state)
        throw authError('Mismatched state');
    return {
        redirectUri,
        code: response.code,
        pkceVerifier: request.internal['code_verifier'],
    };
}
async function revoke(token) {
    await tokenHandler.performRevokeTokenRequest(getAuthConfiguration(), new revoke_token_request_1.RevokeTokenRequest({ token }));
}
async function loginAuthCodeFlow() {
    const { clientId } = environment_1.default().config;
    const { code, pkceVerifier, redirectUri } = await authorize();
    const response = await tokenHandler.performTokenRequest(getAuthConfiguration(), new token_request_1.TokenRequest({
        code,
        client_id: clientId,
        redirect_uri: redirectUri,
        grant_type: token_request_1.GRANT_TYPE_AUTHORIZATION_CODE,
        extras: { code_verifier: pkceVerifier },
    }));
    await storage_1.default.set(response);
}
exports.loginAuthCodeFlow = loginAuthCodeFlow;
async function loginResourceOwnerFlow(username, password) {
    const { clientId } = environment_1.default().config;
    const response = await tokenHandler.performTokenRequest(getAuthConfiguration(), new ResourceOwnerPasswordRequest_1.default({
        username,
        password,
        client_id: clientId,
        grant_type: 'password',
        extras: {
            scope: SCOPES.join(','),
        },
    }));
    await storage_1.default.set(response);
}
exports.loginResourceOwnerFlow = loginResourceOwnerFlow;
async function logout() {
    const authData = await storage_1.default.get();
    if (!authData)
        return;
    await Promise.all([
        revoke(authData.accessToken),
        storage_1.default.clear(),
    ]);
}
exports.logout = logout;
async function getAccessToken() {
    const authData = await storage_1.default.get();
    if (authData === null)
        return null;
    if (authData.isValid(0))
        return authData.accessToken;
    return refreshToken(authData.refreshToken);
}
exports.getAccessToken = getAccessToken;
//# sourceMappingURL=index.js.map