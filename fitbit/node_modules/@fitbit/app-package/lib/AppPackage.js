"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const apr_map_1 = require("apr-map");
const lodash = require("lodash");
function getFile(zip, path) {
    const file = zip.file(path);
    if (!file || file.dir)
        throw new Error(`${path} not present in zip file`);
    return file;
}
function getBufferFromZip(zip, path) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return getFile(zip, path).async('nodebuffer');
    });
}
function getTextFromZip(zip, path) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return getFile(zip, path).async('text');
    });
}
const extractComponentSourceMaps = (sourceMapPaths, zip) => apr_map_1.default(sourceMapPaths, path => getTextFromZip(zip, path).then(JSON.parse));
function extractSourceMaps(zip, sourceMapManifest) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!sourceMapManifest)
            return undefined;
        const extractComponent = (component) => component ? extractComponentSourceMaps(component, zip) : undefined;
        return {
            device: sourceMapManifest.device ? yield apr_map_1.default(sourceMapManifest.device, component => extractComponentSourceMaps(component, zip)) : undefined,
            companion: yield extractComponent(sourceMapManifest.companion),
            settings: yield extractComponent(sourceMapManifest.settings),
        };
    });
}
class ManifestParserBase {
    pullMetadata() {
        return {
            buildId: this.manifest.buildId,
            uuid: this.manifest.appId,
            requestedPermissions: this.manifest.requestedPermissions,
        };
    }
    getSDKVersions() {
        const versions = {
            deviceApi: '1.0.0',
        };
        if (this.manifest.components.companion)
            versions.companionApi = '1.0.0';
        return versions;
    }
}
class ManifestParserV5 extends ManifestParserBase {
    constructor(manifest) {
        super();
        this.manifest = manifest;
    }
    getDeviceComponents() {
        if (typeof this.manifest.components !== 'object' || !this.manifest.components.watch) {
            throw new Error('No components listed in manifest.json');
        }
        if (!Array.isArray(this.manifest.platform)) {
            throw new Error('Missing platform descriptors');
        }
        return this.manifest.platform.map((platformDescriptor) => {
            const [, family, platform] = /^([^:]+):?(.+)?$/.exec(platformDescriptor);
            return [
                family.toLowerCase(),
                {
                    platform: platform ? [platform] : undefined,
                    filename: this.manifest.components.watch,
                },
            ];
        });
    }
    getCompanionFilename() {
        return this.manifest.components.companion;
    }
    getSourceMapExtractor() {
        return () => Promise.resolve(undefined);
    }
}
class ManifestParserV6 extends ManifestParserBase {
    constructor(manifest) {
        super();
        this.manifest = manifest;
    }
    getDeviceComponents() {
        if (typeof this.manifest.components !== 'object') {
            throw new Error('No components listed in manifest.json');
        }
        if (!this.manifest.components.watch)
            return [];
        return Object.entries(this.manifest.components.watch);
    }
    getCompanionFilename() {
        return lodash.get(this.manifest, 'components.companion.filename');
    }
    getSDKVersions() {
        return Object.assign(Object.assign({}, super.getSDKVersions()), this.manifest.sdkVersion);
    }
    getSourceMapExtractor() {
        return (zip) => extractSourceMaps(zip, this.manifest.sourceMaps);
    }
}
function getManifestParser(manifest) {
    switch (manifest.manifestVersion) {
        case 5:
            return new ManifestParserV5(manifest);
        case 6:
            return new ManifestParserV6(manifest);
        default:
            throw new Error(`Unsupported manifest version ${manifest.manifestVersion}`);
    }
}
function fromJSZip(fbaZip) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const textFile = (path) => getTextFromZip(fbaZip, path);
        const bufferFile = (path) => getBufferFromZip(fbaZip, path);
        const manifestJSON = JSON.parse(yield textFile('manifest.json'));
        const parser = getManifestParser(manifestJSON);
        const device = yield Promise.all(parser.getDeviceComponents().map(([family, { platform, filename }]) => bufferFile(filename)
            .then(artifact => [family, { platform, artifact }]))).then(lodash.fromPairs);
        const companionFilename = parser.getCompanionFilename();
        const companion = companionFilename ? yield bufferFile(companionFilename) : undefined;
        const sourceMaps = yield parser.getSourceMapExtractor()(fbaZip);
        return Object.assign(Object.assign({}, parser.pullMetadata()), { sourceMaps, components: {
                device,
                companion,
            }, sdkVersion: parser.getSDKVersions() });
    });
}
exports.fromJSZip = fromJSZip;
//# sourceMappingURL=AppPackage.js.map