"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const events_1 = require("events");
const t = require("io-ts");
const jsonrpc_ts_1 = require("@fitbit/jsonrpc-ts");
const fdb_protocol_1 = require("@fitbit/fdb-protocol");
class Host extends events_1.EventEmitter {
    constructor(hostInfo, timeout) {
        super();
        this.dispatcher = new jsonrpc_ts_1.TypesafeRequestDispatcher();
        this.rpc = new jsonrpc_ts_1.Peer(this.dispatcher);
        this.bulkDataStreams = new fdb_protocol_1.BulkData();
        this.setInstallHandler = (installHandler, installOptions) => {
            this.installHandler = installHandler;
            this.capabilities.io = {
                write: true,
            };
            this.capabilities.appHost = {
                install: Object.assign(Object.assign({}, installOptions), { sideloadStream: true }),
            };
        };
        this.handleInitialize = (params) => {
            this.info = params;
            this.epoch = new Date();
            this.emit('initialized');
            return {
                device: this.hostInfo.device,
                hostKind: this.hostInfo.hostKind,
                capabilities: this.capabilities,
            };
        };
        this.handleAppInstallBegin = (params) => {
            const stream = this.bulkDataStreams.createWriteStream();
            if (this.appInstallStream != null) {
                throw new jsonrpc_ts_1.InvalidParams('App install stream is currently being used');
            }
            this.appInstallStream = stream;
            return {
                stream: stream.token,
            };
        };
        this.handleAppInstallFinalize = ({ stream }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.validateAppInstallStream(stream);
            if (!this.installHandler) {
                throw new jsonrpc_ts_1.InvalidParams('No install handler has been set');
            }
            const finalizedBuffer = this.appInstallStream.finalize();
            this.appInstallStream = undefined;
            return this.installHandler(finalizedBuffer);
        });
        this.handleAppInstallAbort = ({ stream }) => {
            this.validateAppInstallStream(stream);
            this.appInstallStream.finalize();
            this.appInstallStream = undefined;
        };
        this.ping = (timeout = 10000) => this.rpc.callMethod('ping', undefined, { timeout });
        this.consoleMessage = (args) => this.rpc.sendNotification('console.message', args);
        this.consoleTrace = (args) => this.rpc.sendNotification('console.traceMessage', args);
        this.hostInfo = hostInfo;
        this.timeout = timeout;
        this.capabilities = {
            protocol: {
                maxMessageSize: this.hostInfo.maxMessageSize,
            },
        };
        this.dispatcher
            .method('ping', t.undefined, () => { })
            .method('initialize', fdb_protocol_1.FDBTypes.InitializeParams, this.handleInitialize)
            .method('app.install.stream.begin', fdb_protocol_1.FDBTypes.AppInstallStreamBeginParams, this.handleAppInstallBegin)
            .method('app.install.stream.finalize', fdb_protocol_1.FDBTypes.StreamCloseParams, this.handleAppInstallFinalize)
            .method('app.install.stream.abort', fdb_protocol_1.FDBTypes.StreamCloseParams, this.handleAppInstallAbort);
        this.bulkDataStreams.register(this.dispatcher);
    }
    static create(debuggerStream, hostInfo, { timeout = 10000, } = {}) {
        const host = new this(hostInfo, timeout);
        debuggerStream
            .pipe(new jsonrpc_ts_1.ParseJSON)
            .pipe(host.rpc)
            .pipe(new jsonrpc_ts_1.StringifyJSON)
            .pipe(debuggerStream);
        return host;
    }
    validateAppInstallStream(stream) {
        if (!this.appInstallStream) {
            throw new jsonrpc_ts_1.InvalidParams('No current app install stream exists');
        }
        if (stream !== this.appInstallStream.token) {
            throw new jsonrpc_ts_1.InvalidParams('Stream token does not match the current app install stream', { stream });
        }
    }
}
exports.Host = Host;
//# sourceMappingURL=index.js.map